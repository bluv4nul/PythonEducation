# Отчет по лабораторной работе: Генерация бинарного дерева

## Цель работы
Разработать функцию для генерации бинарного дерева с возможностью настройки алгоритмов вычисления потомков и провести тестирование корректности ее работы.

## Задачи
- Реализовать рекурсивную функцию генерации бинарного дерева
- Обеспечить параметризацию алгоритмов вычисления левого и правого потомков
- Реализовать обработку граничных случаев
- Провести комплексное тестирование функции

## Реализация

### Функция `gen_bin_tree`
```python
def gen_bin_tree(height, root, left_func=None, right_func=None):
    if height < 0:
        return {}
    elif height == 0:
        return {root}
    
    if left_func is None:
        left_func = lambda x: x * 2 + 1
    if right_func is None:
        right_func = lambda x: 2 * x - 1
    
    tree = {
        "root": root,
        "left": gen_bin_tree(height-1, left_func(root), left_func, right_func),
        "right": gen_bin_tree(height-1, right_func(root), left_func, right_func)
    }
    return tree
```

### Ключевые особенности реализации:
- **Рекурсивный подход** - дерево строится от корня к листьям
- **Параметризация** - алгоритмы вычисления потомков передаются как аргументы
- **Значения по умолчанию** - left_func: `x*2+1`, right_func: `2*x-1`
- **Граничные случаи**:
  - height < 0: возвращает пустой словарь
  - height = 0: возвращает множество с корнем

## Тестирование

### Набор тестов включает:

1. **`test_height_zero`** - проверка генерации дерева высотой 0
2. **`test_height_one`** - проверка дерева высотой 1
3. **`test_height_two`** - проверка дерева высотой 2
4. **`test_height_three`** - проверка дерева высотой 3
5. **`test_calculation_correctness`** - проверка правильности вычислений
6. **`test_leaf_nodes_are_sets`** - проверка типа данных листьев
7. **`test_negative_height`** - проверка обработки отрицательной высоты
8. **`test_custom_functions`** - проверка работы с кастомными функциями
9. **`test_default_functions_used`** - проверка функций по умолчанию

### Пример тестового случая:
```python
def test_height_two(self):
    result = gen_bin_tree(2, 9)
    expected = {
        "root": 9,
        "left": {
            "root": 19,
            "left": {39},
            "right": {37}
        },
        "right": {
            "root": 17,
            "left": {35},
            "right": {33}
        }
    }
    self.assertEqual(result, expected)
```

## Результаты тестирования

### Структура выходных данных:
- **Высота 0**: множество `{root}`
- **Высота > 0**: словарь с полями:
  - `root`: значение текущего узла
  - `left`: левое поддерево (словарь или множество)
  - `right`: правое поддерево (словарь или множество)

### Пример дерева высотой 2:
```json
{
    "root": 9,
    "left": {
        "root": 19,
        "left": {39},
        "right": {37}
    },
    "right": {
        "root": 17, 
        "left": {35},
        "right": {33}
    }
}
```

## Ключевые особенности

### 1. Гибкость алгоритма
- Возможность использования кастомных функций для вычисления потомков
- Сохранение совместимости со значениями по умолчанию

### 2. Обработка граничных случаев
- Корректная работа с нулевой и отрицательной высотой
- Единообразная структура данных для всех уровней вложенности

### 3. Типы данных
- Листовые узлы представлены как множества
- Внутренние узлы - как словари с четкой структурой

## Выводы

1. **Рекурсивная реализация** успешно справляется с задачей генерации бинарного дерева произвольной высоты
2. **Параметризация алгоритмов** вычисления потомков делает функцию универсальной и переиспользуемой
3. **Структура данных** (словари + множества) обеспечивает четкое разделение между узлами и листьями
4. **Тестовое покрытие** подтверждает корректность работы функции во всех предусмотренных случаях использования

Функция `gen_bin_tree` демонстрирует хороший пример рекурсивного подхода с параметризацией и может быть использована как основа для более сложных алгоритмов работы с деревьями.

---

**Статус:** ✅ Все тесты проходят успешно  
**Coverage:** 100% тестовых сценариев